import random
import math
import numpy as np
import copy
import json

main_probs = {
    'flower' : {'hp': 1},
    'plume'  : {'atk': 1},
    'sands'  : {'hp_': 8,
                'atk_': 8,
                'def_': 8,
                'enerRech_': 3,
                'eleMas': 3},
    'goblet' : {'hp_': 77,
                'atk_': 77,
                'def_': 76,
                'pyro_dmg_': 20, 
                'electro_dmg_': 20,
                'cryo_dmg_': 20,
                'hydro_dmg_': 20,
                'dendro_dmg_': 20,
                'anemo_dmg_': 20,
                'geo_dmg_': 20,
                'physical_dmg_': 20,
                'eleMas': 10},
    'circlet': {'hp_': 11,
                'atk_': 11,
                'def_': 11,
                'critRate_': 5,
                'critDMG_': 5,
                'heal_': 5,
                'eleMas': 2}
}

sub_probs = {
    'hp': 6,
    'atk': 6,
    'def': 6,
    'hp_': 4,
    'atk_': 4,
    'def_': 4,
    'enerRech_': 4,
    'eleMas': 4,
    'critRate_': 3,
    'critDMG_': 3
}

main_values = {
    'hp': 4780,
    'atk': 311,
    'hp_': 46.6,
    'atk_': 46.6,
    'def_': 58.3,
    'pyro_dmg_':  46.6,
    'electro_dmg_': 46.6,
    'cryo_dmg_': 46.6,
    'hydro_dmg_': 46.6,
    'dendro_dmg_': 46.6,
    'anemo_dmg_': 46.6,
    'geo_dmg_': 46.6,
    'physical_dmg_': 58.3,
    'enerRech_': 51.8,
    'eleMas': 186.5,
    'critRate_': 31.1,
    'critDMG_': 62.2,
    'heal_': 34.9
}

sub_values = {
    'hp': 298.75,
    'atk': 19.45,
    'def': 23.13,
    'hp_': 5.83,
    'atk_': 5.83,
    'def_': 7.29,
    'enerRech_': 6.48,
    'eleMas': 23.31,
    'critRate_': 3.89,
    'critDMG_': 7.77
}

# Generate all possible counts of increments that sum to time_steps
def generate_permutations(total, count):
    if count == 1:
        yield [total]
    else:
        for i in range(total + 1):
            for tail in generate_permutations(total - i, count - 1):
                yield [i] + tail

# Calculate the probability for each permutation
def calculate_probability(counts, base_prob):
    numerator = math.factorial(sum(counts))
    denominator = 1
    for count in counts:
        denominator *= math.factorial(count)
    multinomial_coeff = numerator / denominator
    return multinomial_coeff * base_prob

class Artifact:
    def __init__(self, set, lvl, slot, main, substats, lock=False):
        self.set: str = set
        self.lvl: int = lvl
        self.slot: str = slot
        self.main: str = main
        self.substats: dict = substats
        self.lock = lock

    @staticmethod
    def serialize(json_dict):
        """Convert artifact dictionary into artifact object.

        Args:
            json_dict (dict): Dictionary generated by json containing
            artifact info.

        Returns:
            Artifact: _description_
        """
        set: str = json_dict['setKey']
        lvl: int = json_dict['level']
        slot: str = json_dict['slotKey']
        main: str = json_dict['mainStatKey']
        substats = {}
        for substat in json_dict['substats']:
            stat = substat['key']
            value = substat['value']
            coef = round(value / sub_values[stat], 1)
            substats[substat['key']] = coef
        lock = json_dict['lock']

        return Artifact(set, lvl, slot, main, substats, lock=lock)

    def __str__(self):
        return f'set: {self.set}\nlvl: {self.lvl}\nslot: {self.slot}\nmain: {self.main}\nsub: {str(self.substats)}'
    
    def __repr__(self):
        return f'set: {self.set}\nlvl: {self.lvl}\nslot: {self.slot}\nmain: {self.main}\nsub: {str(self.substats)}'
    
    def __hash__(self):
        return hash((self.lvl, self.slot, self.main, str(self.substats)))
    
    def __eq__(self, other):
        return (self.lvl, self.slot, self.main, self.substats) == (other.lvl, other.slot, other.main, other.substats)
    
    def __ne__(self, other):
        return not (self == other)

    def copy(self):
        return copy.deepcopy(self)
    
    @staticmethod
    def generate(lvl=0, slot=None, source='domain'):
        """Randomly generate a single artifact.

        Args:
            lvl (int, optional): Generated artifact's level. Defaults to 0.
            slot (_type_, optional): Generated artifact's slot. If None,
            randomly assign a slot. Defaults to None.
            source (str, optional): The source of the artifact, which
            affects the probability of getting 4 substats at level 0.
            Defaults to 'domain'.

        Raises:
            ValueError: If source is invalid.

        Returns:
            Artifact: Randomly generated artifact
        """
        match source:
            case 'domain':
                prob = 0.2
            case 'normal boss':
                prob = 1/3
            case 'weekly boss':
                prob = 1/3
            case 'strongbox':
                prob = 1/3
            case 'domain reliquary':
                prob = 1/3
            case _:
                raise ValueError('Invalid artifact source.')
            
        num_substats = 4 if random.random() < prob else 3
        
        if slot is None:
            slot = random.choice(['flower', 'plume', 'sands', 'goblet', 'circlet'])
            
        main_options = main_probs[slot]
        main_stat = random.choices(list(main_options.keys()), weights=main_options.values())[0]

        copy_sub_probs = sub_probs.copy()
        copy_sub_probs.pop(main_stat, None)
        prob = np.array(list(copy_sub_probs.values()), dtype=float)
        prob /= np.sum(prob)
        sub_stats = np.random.choice(list(copy_sub_probs.keys()), size=num_substats, replace=False, p=prob)

        substats = {}
        for sub in sub_stats:
            substats[sub] = 1

        artifact = Artifact(0, slot, main_stat, substats)
        num_upgrades = lvl // 4 # TODO: find a better way to do this
        for _ in range(num_upgrades):
            artifact.random_upgrade()

        return artifact

    def random_upgrade(self):
        """Randomly upgrade artifact in place a single time.

        Raises:
            ValueError: If artifact is already max level.
        """
        if self.lvl == 20:
            raise ValueError('Cannot upgrade level 20 artifact')
        
        if len(self.substats.keys()) == 3:
            copy_sub_probs = sub_probs.copy()
            copy_sub_probs.pop(self.main, None)
            for substat in self.substats.keys():
                copy_sub_probs.pop(substat, None)
            probs = np.array(list(copy_sub_probs.values()), dtype=float)
            probs /= np.sum(probs)
            new_sub = random.choices(list(copy_sub_probs.keys()), weights=probs)[0]
            self.substats[new_sub] = 1 # TODO: add coef

        else:
            temp = random.randint(0, 15)
            upgrade_idx = temp // 4
            # upgrade_coef = [0.7, 0.8, 0.9, 1][temp % 4] TODO: add coef
            upgrade_coef = 1
            self.substats[list(self.substats.keys())[upgrade_idx]] += upgrade_coef
        
        self.lvl = (self.lvl // 4) * 4 + 4

    def upgrade_distro(self, lvl):
        """Calculate the artifact's possible upgrades and their
        probability distribution.

        Args:
            lvl (int): Target level after upgrading

        Returns:
            dict: Dictionary with a key for every possible resulting
            artifact after upgrading. The value is the key's
            corresponding probability.
        """
        num_upgrades = (lvl // 4) - (self.lvl // 4)

        if self.lvl == 12:
            pass

        if len(self.substats) == 3:
            num_upgrades -= 1
            self.substats[None] = 1

        # Base probability for each sequence
        base_prob = (1 / 4) ** num_upgrades

        # Generate permutations and calculate probabilities
        possibilities = {}
        total_prob = 0
        for counts in generate_permutations(num_upgrades, 4):
            prob = calculate_probability(counts, base_prob)
            temp = self.copy()
            temp.lvl = lvl
            for idx, substat in enumerate(temp.substats.keys()):
                temp.substats[substat] += counts[idx] * 0.85
            
            possibilities[temp] = prob
            total_prob += prob
        
        if None in self.substats:
            total_prob = 0
            temp_possibilities = {}

            for possibility, prob in possibilities.items():
                copy_sub_probs = sub_probs.copy()
                copy_sub_probs.pop(possibility.main, None)
                for substat in possibility.substats.keys():
                    copy_sub_probs.pop(substat, None)
                probs = np.array(list(copy_sub_probs.values()), dtype=float)
                probs /= np.sum(probs)
                for idx, sub in enumerate(copy_sub_probs.keys()):
                    temp = possibility.copy()
                    temp.substats.pop(None, None)
                    temp.substats[sub] = possibility.substats[None]
                    temp_possibilities[temp] = prob * probs[idx]
                    total_prob += prob * probs[idx]
            
            possibilities = temp_possibilities
            self.substats.pop(None, None)

        return possibilities
    
    def score(self, targets: dict):
        """Calculate the current score.

        Args:
            targets (dict): Dictionary mapping a stat to a weight to
            base the score.

        Returns:
            float: Score
        """
        score = 0
        if self.main in targets:
            if self.main == 'hp' or self.main == 'atk':
                score = 16/3 * targets[self.main]
            else:
                score = 8 * targets[self.main] # TODO: make sure this is correct

        for substat, value in self.substats.items():
            if substat not in targets:
                continue

            score += value * targets[substat]

        return score

    @staticmethod
    def mean_score(distro: dict, targets: dict):
        """Calculate the average score if randomly upgrading an
        artifact.

        Args:
            distro (dict): Dictionary mapping possibile resultant
            upgrades to their probabilities. Generated by
            upgrade_distro.
            targets (dict): Dictionary mapping a stat to a weight to
            base the score. 

        Raises:
            ValueError: Distribution doesn't add to 1.

        Returns:
            float: Average score
        """
        total = 0

        if not math.isclose(sum(distro.values()), 1):
            raise ValueError('Distribution doesn\'t add to 1.')

        for artifact, prob in distro.items():
            total += artifact.score(targets) * prob

        return total
    
    @staticmethod
    def sort_potential(artifacts, targets_list, special_targets_list=None, 
                       set_targets_list=None): # TODO: maybe think of better name
        distros = []
        for artifact in artifacts:
            distros.append((artifact.upgrade_distro(20), artifact.set))

        num_special_targets = 0 if special_targets_list is None else len(special_targets_list)
        num_set_targets = 0 if set_targets_list is None else len(set_targets_list)
        
        means = np.zeros((len(artifacts), len(targets_list) + num_special_targets + num_set_targets))
        sorted_idxs = np.zeros_like(means, dtype=int)

        for idx, (targets, num) in enumerate(targets_list):
            target_means = [Artifact.mean_score(distro, targets) for distro, _ in distros]

            sorted_means = sorted(target_means, reverse=True)
            sorted_idx = np.array([sorted_means.index(mean) for mean in target_means], dtype=int)
            sorted_idx[sorted_idx >= num] = np.iinfo(sorted_idx.dtype).max
            sorted_idxs[:, idx] = sorted_idx
            means[:, idx] = target_means

        if special_targets_list is not None:
            for idx, (targets, num) in enumerate(special_targets_list):
                idx += len(targets_list)
                target_means = [Artifact.mean_score(distro, targets) for distro, _ in distros]

                sorted_means = sorted(target_means, reverse=True)
                sorted_idx = np.array([sorted_means.index(mean) for mean in target_means], dtype=int)
                sorted_idx[sorted_idx >= num] = np.iinfo(sorted_idx.dtype).max
                sorted_idxs[:, idx] = sorted_idx
                means[:, idx] = target_means
        
        if set_targets_list is not None:
            for idx, (set, targets, num) in enumerate(set_targets_list):
                idx += len(targets_list) + num_special_targets
                target_means = []
                for distro, distro_set in distros:
                    if set == distro_set:
                        target_means.append(Artifact.mean_score(distro, targets))
                    else:
                        target_means.append(-1)

                sorted_means = sorted(target_means, reverse=True)
                sorted_idx = np.array([sorted_means.index(mean) for mean in target_means], dtype=int)
                #sorted_idx[sorted_idx >= num] = np.iinfo(sorted_idx.dtype).max
                sorted_idx[sorted_idx >= num] = np.iinfo(sorted_idx.dtype).max
                try:
                    if sorted_means.index(-1) < num:
                        sorted_idx[sorted_idx >= sorted_means.index(-1)] = np.iinfo(sorted_idx.dtype).max
                except:
                    pass
                sorted_idxs[:, idx] = sorted_idx
                means[:, idx] = target_means

        np.save('asdf.npy', sorted_idxs)
        min_idx = list(np.min(sorted_idxs, axis=1))

        #output = dict(zip(artifacts, zip(min_idx, means)))
        #return dict(sorted(output.items(), key=lambda item: item[1][0], reverse=True))
        output = dict(zip(artifacts, min_idx))
        return dict(sorted(output.items(), key=lambda item: item[1], reverse=True))

    @staticmethod
    def read_json(filename, split=False):
        """Read JSON of artifacts.

        Args:
            filename (str): JSON filename.
            split (bool, optional): Whether to split the list of
            artifacts into 6 separate lists based on their levels.
            Defaults to False. 

        Raises:
            ValueError: If format isn't GOOD.

        Returns:
            list: List of List of Artifact if split, List of Artifact
            otherwise.
        """
        with open(filename) as f:
            data = json.load(f) 
        
        if data['format'] != 'GOOD':
            raise ValueError('Format is not GOOD')
        
        artifacts = []
        artifact_dicts = data['artifacts']

        if split:
            buckets = [[] for _ in range(6)]
            for artifact_dict in artifact_dicts:
                if artifact_dict['rarity'] != 5:
                    continue

                (buckets[artifact_dict['level'] // 4]).append(Artifact.serialize(artifact_dict))

            return buckets
        else:
            for artifact_dict in artifact_dicts:
                if artifact_dict['rarity'] != 5:
                    continue

                artifacts.append(Artifact.serialize(artifact_dict))
        
        return artifacts
    
    @staticmethod
    def split_slot(artifacts):
        """Split a list of artifacts into 5 seperate lists based on
        their slots.

        Args:
            artifacts (list): List of Artifact objects.

        Raises:
            ValueError: Artifact is malformed and has an invalid slot.

        Returns:
            tuple: Tuple of 5 lists for each slot
        """
        flowers = []
        plumes = []
        sands = []
        goblets = []
        circlets = []
        for artifact in artifacts:
            match artifact.slot:
                case 'flower':
                    flowers.append(artifact)
                case 'plume':
                    plumes.append(artifact)
                case 'sands':
                    sands.append(artifact)
                case 'goblet':
                    goblets.append(artifact)
                case 'circlet':
                    circlets.append(artifact)
                case _:
                    raise ValueError('Invalid artifact slot')
        
        return flowers, plumes, sands, goblets, circlets
    
    @staticmethod
    def split_lvl(artifacts):
        """Split a list of artifacts into 6 seperate lists based on
        their levels.

        Args:
            artifacts (list): List of Artifact objects.

        Raises:
            ValueError: Artifact is malformed and has an invalid level.

        Returns:
            tuple: Tuple of 6 lists for each level
        """
        # TODO: This is so stupid lmao but it works, im too lazy to make
        # it smarter
        zeros = []
        fours = []
        eights = []
        twelves = []
        sixteens = []
        twenties = []
        for artifact in artifacts:
            match artifact.lvl // 4:
                case 0:
                    zeros.append(artifact)
                case 1:
                    fours.append(artifact)
                case 2:
                    eights.append(artifact)
                case 3:
                    twelves.append(artifact)
                case 4:
                    sixteens.append(artifact)
                case 5:
                    twenties.append(artifact)
                case _:
                    raise ValueError('Invalid artifact level')

        return zeros, fours, eights, twelves, sixteens, twenties