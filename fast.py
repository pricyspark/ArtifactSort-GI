import random
import math
import numpy as np
import copy
import json
import functools
#from memory_profiler import profile
#from numba import jit, njit
#from numba.experimental import jitclass
#from collections.abc import Iterable
from pathlib import Path

# 0: hp
# 1: atk
# 2: def
# 3: hp_
# 4: atk_
# 5: def_
# 6: enerRech_
# 7: eleMas
# 8: critRate_
# 9: critDMG_
# 10: pyro_dmg_
# 11: electro_dmg_
# 12: cryo_dmg_
# 13: hydro_dmg_
# 14: dendro_dmg_
# 15: anemo_dmg_
# 16: geo_dmg_
# 17: physical_dmg_
# 18: heal_

FLOAT_DTYPE = np.float64

STATS = [
    'hp', 'atk', 'def', 'hp_', 'atk_', 'def_', 'enerRech_', 'eleMas', 
    'critRate_', 'critDMG_', 'pyro_dmg_', 'electro_dmg_', 'cryo_dmg_', 
    'hydro_dmg_', 'dendro_dmg_', 'anemo_dmg_', 'geo_dmg_', 'physical_dmg_', 
    'heal_'
]

STAT_2_NUM = {stat: index for index, stat in enumerate(STATS)}

MAIN_PROBS = {
    'flower': {
        'hp': 1
    },
    'plume': {
        'atk': 1
    },
    'sands': {
        'hp_': 8/30,
        'atk_': 8/30,
        'def_': 8/30,
        'enerRech_': 3/30,
        'eleMas': 3/30
    },
    'goblet': {
        'hp_': 77/400,
        'atk_': 77/400,
        'def_': 76/400,
        'pyro_dmg_': 20/400,
        'electro_dmg_': 20/400,
        'cryo_dmg_': 20/400,
        'hydro_dmg_': 20/400,
        'dendro_dmg_': 20/400,
        'anemo_dmg_': 20/400,
        'geo_dmg_': 20/400,
        'physical_dmg_': 20/400,
        'eleMas': 10/400
    },
    'circlet': {
        'hp_': 11/50,
        'atk_': 11/50,
        'def_': 11/50,
        'critRate_': 5/50,
        'critDMG_': 5/50,
        'heal_': 5/50,
        'eleMas': 2/50
    }
}

SUB_PROBS = [6, 6, 6, 4, 4, 4, 4, 4, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0]

MAIN_VALUES = {
    'hp': 4780,
    'atk': 311,
    'hp_': 46.6,
    'atk_': 46.6,
    'def_': 58.3,
    'pyro_dmg_':  46.6,
    'electro_dmg_': 46.6,
    'cryo_dmg_': 46.6,
    'hydro_dmg_': 46.6,
    'dendro_dmg_': 46.6,
    'anemo_dmg_': 46.6,
    'geo_dmg_': 46.6,
    'physical_dmg_': 58.3,
    'enerRech_': 51.8,
    'eleMas': 186.5,
    'critRate_': 31.1,
    'critDMG_': 62.2,
    'heal_': 34.9
}

SUB_VALUES = {
    'hp': 298.75,
    'atk': 19.45,
    'def': 23.13,
    'hp_': 5.83,
    'atk_': 5.83,
    'def_': 7.29,
    'enerRech_': 6.48,
    'eleMas': 23.31,
    'critRate_': 3.89,
    'critDMG_': 7.77
}

SUB_COEFS = (21, 24, 27, 30)

ARTIFACT_REQ_EXP = [
    0,
    3000,
    6725,
    11150,
    16300,
    22200,
    28875,
    36375,
    44725,
    53950,
    64075,
    75125,
    87150,
    100175,
    115325,
    132925,
    153300,
    176800,
    203850,
    234900,
    270475
]

# Generate all possible counts of increments that sum to time_steps
def generate_permutations(total, count):
    if count == 1:
        yield [total]
    else:
        for i in range(total + 1):
            for tail in generate_permutations(total - i, count - 1):
                yield [i] + tail

# Calculate the probability for each permutation
def calculate_probability(counts, base_prob):
    numerator = math.factorial(sum(counts))
    denominator = 1
    for count in counts:
        denominator *= math.factorial(count)
    multinomial_coeff = numerator / denominator
    return multinomial_coeff * base_prob

class FastArtifact:
    score_cdfs = {}

    def __init__(self, set, lvl, slot, main=None, substats=None, stats=None, lock=False):

        self.set: str = set
        self.lvl: int = lvl
        self.slot: str = slot
        self.lock = lock

        if stats is not None:
            mask = stats == 160 # 16/3 * 30
            if np.any(mask):
                self.main = np.argmax(stats == 160)
            else:
                self.main = np.argmax(stats)

            self.substats = np.nonzero(stats)[0].tolist()
            self.substats.remove(self.main)
            self.stats = stats
            return

        self.main: int = STAT_2_NUM[main]
        self.substats: list = [STAT_2_NUM[substat] for substat in substats.keys()]
        self.stats = np.zeros(19, dtype=np.uint8)

        if self.main < 3:
            self.stats[self.main] = 160 # 16/3 * 30
        else:
            self.stats[self.main] = 240 # 8 * 30

        for substat, value in substats.items():
            self.stats[STAT_2_NUM[substat]] = value

    @staticmethod
    def serialize(json_dict):
        """Convert artifact dictionary into artifact object.

        Args:
            json_dict (dict): Dictionary generated by json containing
            artifact info.

        Returns:
            FastArtifact: _description_
        """
        
        set: str = json_dict['setKey']
        lvl: int = json_dict['level']
        slot: str = json_dict['slotKey']
        main: str = json_dict['mainStatKey']
        substats = {}
        for substat in json_dict['substats']:
            stat = substat['key']
            value = substat['value']
            coef = round(value / SUB_VALUES[stat] * 30)
            substats[substat['key']] = coef
        lock = json_dict['lock']

        return FastArtifact(set, lvl, slot, main, substats, lock=lock)

    # TODO: round substat floats when printing, maybe by modifying or
    # just the displayed value
    def __str__(self):
        output = f'set: {self.set}\nlvl: {self.lvl}\nslot: {self.slot}\nmain: {STATS[self.main]}\nsub: {{'
        for idx, substat_idx in enumerate(self.substats):
            if idx != 0:
                output += ', '
            output += f'\'{str(STATS[substat_idx])}\': {self.stats[substat_idx]}'
        output += '}'
        return output
    
    def __repr__(self):
        output = f'set: {self.set}\nlvl: {self.lvl}\nslot: {self.slot}\nmain: {STATS[self.main]}\nsub: {{'
        for idx, substat_idx in enumerate(self.substats):
            if idx != 0:
                output += ', '
            output += f'\'{str(STATS[substat_idx])}\': {self.stats[substat_idx]}'
        output += '}'
        return output
    
    def __hash__(self):
        #return hash((self.lvl, self.slot, self.main, tuple(self.substats)))
        return hash((self.lvl, self.slot, self.stats.tobytes()))
    
    def __eq__(self, other):
        return (
            self.set == other.set and
            self.lvl == other.lvl and
            self.slot == other.slot and
            self.main == other.main and
            np.array_equal(self.substats, other.substats) and
            np.array_equal(self.stats, other.stats)
        )
    
    def __ne__(self, other):
        return not (self == other)

    @staticmethod
    def generate(set: str, lvl=0, slot=None, main=None, source='domain', rng=None, seed=None):
        """Randomly generate a single artifact.

        Args:
            set (str): Generated artifact's set.
            lvl (int, optional): Generated artifact's level. Defaults to 0.
            slot (str, optional): Generated artifact's slot. Defaults to None.
            main (int, optional): Generated artifact's main stat index.
            Defaults to None.
            source (str, optional): Source of obtaining artifact. This
            changes the probability it has 4 substats at level 0.
            Defaults to 'domain'.
            rng (Generator, optional): Preseeded numpy Generator object.
            If passed, ignore seed and use this. Defaults to None.
            seed (int, optional): If no numpy Generator is provided, use this
            to create a new one. Defaults to None.
        
        Raises:
            ValueError: If source is invalid.
            ValueError: If main stat is not valid for given slot.

        Returns:
            FastArtifact: Randomly generated artifact.
        """
        
        if rng is None:
            rng = np.random.default_rng(seed)
        
        match source:
            case 'domain':
                prob = 0.2
            case 'normal boss':
                prob = 1/3
            case 'weekly boss':
                prob = 1/3
            case 'strongbox':
                prob = 1/3
            case 'domain reliquary':
                prob = 1/3
            case _:
                raise ValueError('Invalid artifact source.')
            
        num_substats = 4 if rng.random() < prob else 3
        
        if slot is None:
            slot = rng.choice(('flower', 'plume', 'sands', 'goblet', 'circlet'))
            
        if main is None:
            main_options = MAIN_PROBS[slot]
            main_stat = rng.choice(list(main_options.keys()), p=list(main_options.values()))
        else:
            if main not in MAIN_PROBS[slot].keys():
                raise ValueError(f'Invalid main stat: {main}')
            main_stat = main

        stats = np.zeros(19, dtype=np.uint8)
        main_idx = STAT_2_NUM[main_stat]
        if main_idx < 3:
            stats[main_idx] = 160
        else:
            stats[main_idx] = 240

        copy_SUB_PROBS = np.array(SUB_PROBS)
        copy_SUB_PROBS[main_idx] = 0
        probs = copy_SUB_PROBS / np.sum(copy_SUB_PROBS)

        sub_stats = rng.choice(19, size=num_substats, replace=False, p=probs)
        #sub_stats = np.random.choice(19, size=num_substats, replace=False, p=probs)
        
        for sub in sub_stats:
            stats[sub] = rng.choice(SUB_COEFS)

        artifact = FastArtifact(set, 0, slot, main_stat, stats=stats)
        artifact.upgrade_until(lvl, rng, seed)

        return artifact

    def random_upgrade(self, rng=None, seed=None):
        """Randomly upgrade artifact in place.

        Args:
            rng (Generator, optional): Preseeded numpy Generator object.
            If passed, ignore seed and use this. Defaults to None.
            seed (int, optional): If no numpy Generator is provided, use this
            to create a new one. Defaults to None.

        Raises:
            ValueError: If artifact is already max level.
        """
        
        if self.lvl == 20:
            raise ValueError('Cannot upgrade level 20 artifact')
        
        if rng is None:
            rng = np.random.default_rng(seed)

        if len(self.substats) == 3:
            probs = np.array(SUB_PROBS, dtype=FLOAT_DTYPE)
            # probs = np.array(list(SUB_PROBS_DICT.values()), dtype=FLOAT_DTYPE)
            if self.main < 10:
                probs[self.main] = 0
            for sub in self.substats:
                probs[sub] = 0
            probs /= np.sum(probs)

            new_sub = rng.choice(STATS, p=probs)
            # new_sub = rng.choice(list(SUB_PROBS_DICT.keys()), p=probs) # TODO: this doesn't need to use SUB_PROBS_DICT only SUB_PROB since it immediately converts the substat back to idx
            #new_sub = random.choices(list(copy_SUB_PROBS_DICT.keys()), weights=probs)[0]
            self.substats.append(STAT_2_NUM[new_sub])
            self.stats[STAT_2_NUM[new_sub]] = rng.choice(SUB_COEFS)

        else:
            temp = rng.integers(16)
            upgrade_idx = temp // 4
            upgrade_coef = SUB_COEFS[temp % 4]

            self.stats[self.substats[upgrade_idx]] += upgrade_coef

        self.lvl = (self.lvl // 4) * 4 + 4

    def upgrade_until(self, lvl, rng=None, seed=None):
        while self.lvl // 4 < lvl // 4:
            self.random_upgrade(rng, seed)

        self.lvl = lvl

    #@functools.lru_cache(maxsize=CACHE_SIZE)
    @staticmethod
    #@lru_cache_with_numpy(maxsize=CACHE_SIZE)
    def upgrade_distro(num_upgrades: int, stats: np.ndarray):
        """Artifact's possible max upgrades and their probability
        distribution.

        Args:
            num_upgrades (int): How many upgrades needed to max.
            stats (NDArray): Current artifact's stats to base the
            possibilites off of.

        Returns:
            tuple(NDArray, NDArray): First array is possibilities. Each
            row represents the stats of the maxed artifact. Second array
            probabilities corresponding to each row of possibilities.
        """

        mask = stats == 160
        if np.any(mask):
            main = np.argmax(stats == 160)
        else:
            main = np.argmax(stats)

        substats = np.nonzero(stats)[0].tolist()
        substats.remove(main)

        # Check if currently only 3 substats
        add_substat = False
        if len(substats) == 3:
            num_upgrades -= 1
            permutations = list(generate_permutations(num_upgrades, 4))
            add_substat = True

            # Create list of possible extra substat
            new_probs = np.array(SUB_PROBS, dtype=FLOAT_DTYPE)
            new_probs[main] = 0
            for substat_idx in substats:
                new_probs[substat_idx] = 0
            new_probs /= np.sum(new_probs)
            
            num_new = np.count_nonzero(new_probs)
            num_possibilities = len(permutations) * num_new
        else:
            permutations = list(generate_permutations(num_upgrades, 4))
            num_possibilities = len(permutations)
        
        possibilities = np.tile(stats, (1 + num_possibilities, 1))
        probs = np.zeros(1 + num_possibilities)

        # Base probability for each sequence
        base_prob = (1 / 4) ** num_upgrades

        counter = 1

        for idx, counts in enumerate(permutations): # For each permutation
            prob = calculate_probability(counts, base_prob)
            for i, substat_idx in enumerate(substats): # Fill in its columns
                if add_substat:
                    possibilities[counter:counter+num_new, substat_idx] += counts[i] * 24 # TODO: this doesn't work because 0.85 * 30 isn't an integer. Either multiply by 60 instead of 30, stop using 0.85 as an estimate, or use 0.8 which would underestimate upgardes. This may be fine bc tuning may counteract this. Not ideal though.
                    #probs[counter:counter+len(copy_SUB_PROBS_DICT)] = prob * np.array(copy_SUB_PROBS_DICT.values())
                else:
                    possibilities[counter, substat_idx] += 24 * counts[i]
                    probs[counter] = prob
                    
            if add_substat:
                for sub_idx, sub_prob in enumerate(new_probs):
                    if sub_prob == 0:
                        continue
                    possibilities[counter, sub_idx] += 24 * (counts[3] + 1)
                    probs[counter] = prob * sub_prob
                    counter += 1
            else:
                counter += 1

        return possibilities, probs
    
    @staticmethod
    def sample_distro(distro: tuple):
        """Randomly sample an artifact from a distro and return its
        stats.

        Args:
            distro (tuple): Tuple returned from upgrade_distro(). First
            array is possibilities. Each row represents the stats of the
            maxed artifact. Second array probabilities corresponding to
            each row of possibilities.

        Returns:
            NDArray: Stats of the sampled artifact.
        """
        
        possibilities, probs = distro
        row = np.random.choice(possibilities.shape[0], p=probs)
        return possibilities[row, :]
    
    @staticmethod
    def generate_funs(filename):
        with open(filename) as f:
            data = json.load(f)
            
        output = []
        for fun in data:
            num = fun['num']
            targets = FastArtifact.vectorize_targets(fun['targets'])
            metrics = fun['metrics']
                
            def out_fun(artifact, num=num, targets=targets, metrics=metrics):
                if artifact is None:
                    return num
                
                num_upgrades = 5 - (artifact.lvl // 4)
                distro = FastArtifact.upgrade_distro(num_upgrades, artifact.stats)
                output = 0
                for metric, coef in metrics.items():
                    output += eval(metric) * coef
                    
                return output
            
            output.append(out_fun)
        return output
    
    @staticmethod
    def vectorize_targets(targets: dict):
        """Convert a target dictionary to a target array.

        Args:
            targets (dict): Mapping from stat to weight. Weights must be
            ints, or they will be cast.

        Returns:
            NDArray: Array of stat weights.
        """
        
        output = np.zeros(19, dtype=np.uint32)
        for target, value in targets.items():
            if target == 'crit_':
                output[8] = value
                output[9] = value
                continue

            output[STAT_2_NUM[target]] = value

        return output
    
    @staticmethod
    def unvectorize_targets(targets):
        """Convert a target array back to a target dictionary.

        Args:
            targets (NDArray): Array of stat weights.

        Returns:
            dict: Mapping from stat to weight
        """
        
        out_list = []
        nonzero = np.nonzero(targets)[0]
        for idx in nonzero:
            out_list.append((idx, targets[idx]))
        
        return tuple(out_list)

    # TODO: maybe cache
    def score(self, targets: np.ndarray):
        """Current score for given targets.

        Args:
            targets (NDArray): Vectorized array of target weights.

        Returns:
            float: Calculated score
        """
        
        return self.stats @ targets
    
    @staticmethod
    def score_maxed(artifacts, targets_list):
        output = np.zeros((len(artifacts), len(targets_list)), dtype=float)
        for artifact_idx, artifact in enumerate(artifacts):
            for targets_idx, targets in enumerate(targets_list):
                output[artifact_idx, targets_idx] = artifact.stats @ targets
                
        return output
    
    @staticmethod
    def score_nonmaxed(artifacts, funs):
        output = np.zeros((len(artifacts), len(funs)), dtype=float)
        for artifact_idx, artifact in enumerate(artifacts):
            for fun_idx, fun in enumerate(funs):
                output[artifact_idx, fun_idx] = fun(artifact)
                
        return output
    
    @staticmethod
    def score_nonmaxed_relative(artifacts, funs):
        scores = FastArtifact.score_nonmaxed(artifacts, funs)
        output = np.zeros_like(scores)
        for i, col in enumerate(scores.T):
            order = np.argsort(col)[::-1]
            result = np.zeros_like(order)
            result[order] = np.arange(len(col))
            output[:, i] = result
            
        return output
    
    @staticmethod
    def rate(artifacts, funs):
        relative_scores = FastArtifact.score_nonmaxed_relative(artifacts, funs)
        output = np.zeros_like(relative_scores, dtype=bool)
        for i, fun in enumerate(funs):
            output[relative_scores[:, i] < fun(None), i] = True
            
        #return output
        return output.any(axis=1)

    #@functools.lru_cache(maxsize=CACHE_SIZE)
    @staticmethod
    #@lru_cache_nested_numpy(maxsize=CACHE_SIZE)
    def score_mean(distro: tuple, targets: np.ndarray):
        """Average score if maxing an artifact.

        Args:
            distro (tuple): Tuple returned from upgrade_distro(). First
            array is possibilities. Each row represents the stats of the
            maxed artifact. Second array probabilities corresponding to
            each row of possibilities.
            targets (NDArray): Vectorized array of target weights.

        Raises:
            ValueError: Distribution probabilities don't add to 1.

        Returns:
            float: Calculated average score
        """
        
        possibilities, probs = distro
        if not math.isclose(np.sum(probs), 1):
            raise ValueError(f'Distribution probabilities add to {np.sum(probs)}, not 1')
        
        return (possibilities @ targets) @ probs
    
    #@functools.lru_cache(maxsize=CACHE_SIZE)
    @staticmethod
    #@lru_cache_nested_numpy(maxsize=CACHE_SIZE)
    def score_second_moment(distro: tuple, targets: np.ndarray):
        """Second moment of a distro's scores for the
        given targets.

        Args:
            distro (tuple): Tuple returned from upgrade_distro(). First
            array is possibilities. Each row represents the stats of the
            maxed artifact. Second array probabilities corresponding to
            each row of possibilities.
            targets (NDArray): Vectorized array of target weights.

        Raises:
            ValueError: Distribution probabilities don't add to 1.

        Returns:
            float: Calculated second moment score
        """
        
        possibilities, probs = distro
        
        if not math.isclose(np.sum(probs), 1):
            raise ValueError(f'Distribution probabilities add to {np.sum(probs)}, not 1')
        
        return np.square(possibilities @ targets) @ probs

    # TODO: maybe fix this code duplication, but it would make it 2x
    # slower without caching
    #@functools.lru_cache(maxsize=CACHE_SIZE)
    @staticmethod
    #@lru_cache_with_numpy(maxsize=CACHE_SIZE)
    def score_std_dev(distro: tuple, targets: np.ndarray):
        """Standard deviation of a distro's scores for given
        targets.

        Args:
            distro (tuple): Tuple returned from upgrade_distro(). First
            array is possibilities. Each row represents the stats of the
            maxed artifact. Second array probabilities corresponding to
            each row of possibilities.
            targets (NDArray): Vectorized array of target weights.

        Returns:
            float: Calculated standard deviation score
        """
        
        return math.sqrt(FastArtifact.score_second_moment(distro, targets) - (FastArtifact.score_mean(distro, targets) ** 2))

    @classmethod
    def class_top_x_per(cls, scores, slot, targets):
        """Probability a random maxed artifact of the same
        slot needed to beat a given score for the given targets. Save
        score cumulative density function as class variable. Try to load
        from file first, generating from scratch and saving if needed.

        Args:
            scores (NDArray): Array of scores, which each generate a
            separate probability.
            slot (str): Artifact slot for the scores.
            targets (NDArray): Vectorized array of target weights.

        Returns:
            NDArray: Array of probabilities for each score.
        """
        
        unvect_targets = FastArtifact.unvectorize_targets(targets)
        # key = slot + '_' + main

        if unvect_targets not in FastArtifact.score_cdfs:
            FastArtifact.score_cdfs[unvect_targets] = {}

        if slot not in FastArtifact.score_cdfs[unvect_targets]:
            filename = 'distros/scores/'
            for idx, coef in unvect_targets:
                filename += str(idx) + '_' + str(coef) + '_'

            filename = filename[:-1]
            Path(filename).mkdir(parents=True, exist_ok=True)
            filename += '/' + slot + '.npy'
            try: # TODO: maybe check for the file to prevent nesting
                FastArtifact.score_cdfs[unvect_targets][slot] = np.load(filename)
            except:
                print('Scores not found. Generating...')
                upgrades = np.load('distros/upgrades.npy') # Maybe don't repeat this
                probs = np.load('distros/upgrade_probs.npy')
                bases = np.load(f'distros/{slot}.npy')
                
                distro = {}
                for idx, base in enumerate(bases):
                    for upgrade, prob in zip(upgrades, probs):
                        stats = np.zeros(19, dtype=np.uint8)

                        main = base[0]
                        if main < 3:
                            stats[int(main)] = 160
                        else:
                            stats[int(main)] = 240

                        for a, b in zip(base[1:], upgrade):
                            b = np.uint8(b)
                            stats[int(a)] = b * 3

                        score = stats @ targets
                        
                        
                        total_prob = prob * base[-1]
                        
                        if score in distro:
                            distro[score] += total_prob
                        else:
                            distro[score] = total_prob
                        '''
                        key = close_key(distro, score)
                        if key is None:
                            print('new key:', score)
                            distro[score] = total_prob
                        else:
                            distro[key] += total_prob
                        '''

                cdf = np.zeros((len(distro), 2))
                cdf[:, 0] = sorted(distro.keys())
                # sorted_scores = np.array(sorted(distro.keys()))
                total_probs = np.array([distro[score] for score in cdf[:, 0]])
                cdf[:, 1] = np.cumsum(total_probs)

                FastArtifact.score_cdfs[unvect_targets][slot] = cdf
                np.save(filename, cdf)
                print('Scores generated and saved.')

        cdf = FastArtifact.score_cdfs[unvect_targets][slot]
        indices = np.searchsorted(cdf[:, 0], scores, side='left')

        return 1 - cdf[:, 1][indices]
    
    def top_x_per(self, targets):
        """Probability a random maxed artifact of the same
        slot needed to beat current artifact's score for the given targets.

        Args:
            targets (NDArray): Vectorized array of target weights.

        Raises:
            ValueError: If current artifact isn't maxed.

        Returns:
            float: Calculated probability.
        """
        
        if self.lvl != 20:
            raise ValueError('Can only rate maxed artifacts.')
        
        score = self.score(targets)
        slot = self.slot
        return FastArtifact.class_top_x_per(score, slot, targets)
    
    @classmethod
    def req_to_beat_mean(cls, distro, targets, slot):
        """Average number of maxed artifacts of the same slot needed to
        beat the distro's score for the given targets.

        Args:
            distro (tuple): Tuple returned from upgrade_distro(). First
            array is possibilities. Each row represents the stats of the
            maxed artifact. Second array probabilities corresponding to
            each row of possibilities.
            targets (NDArray): Vectorized array of target weights.
            slot (str): Artifact slot for the scores.

        Returns:
            float: Calculated average number of artifacts
        """
        
        possibilities, probs = distro
        scores = possibilities @ targets
        percents = FastArtifact.class_top_x_per(scores, slot, targets)
        num_req = 1 / percents
        return num_req @ probs
    
    @classmethod
    def req_to_beat_second_moment(cls, distro, targets, slot):
        """Second moment of the number of maxed artifacts of the same
        slot needed to beat the distro's score for the given targets.

        Args:
            distro (tuple): Tuple returned from upgrade_distro(). First
            array is possibilities. Each row represents the stats of the
            maxed artifact. Second array probabilities corresponding to
            each row of possibilities.
            targets (NDArray): Vectorized array of target weights.
            slot (str): Artifact slot for the scores.

        Returns:
            float: Calculated second moment number of artifacts
        """
        
        possibilities, probs = distro
        scores = possibilities @ targets
        percents = FastArtifact.class_top_x_per(scores, slot, targets)
        num_req = 1 / percents
        return np.square(num_req) @ probs

    @staticmethod
    def upgrade_req_exp(lvl):
        """Artifact EXP required to upgrade, starting from given level.

        Args:
            lvl (int): Target artifact level

        Returns:
            int: Calculated artifact EXP
        """
        
        upgrade_lvl = 4 * ((lvl // 4) + 1)
        return ARTIFACT_REQ_EXP[upgrade_lvl] - ARTIFACT_REQ_EXP[lvl]

    @staticmethod
    def max_req_exp(lvl):
        """Estimate how much EXP is needed to fully upgrade an artifact
        with the given level. Only an estimate because exact current EXP
        is unknown.

        Args:
            lvl (int): Current artifact's level

        Returns:
            int: Estimated EXP
        """
        
        return ARTIFACT_REQ_EXP[20] - ARTIFACT_REQ_EXP[lvl]

    @staticmethod
    def salvage_exp(lvl):
        """Estimate how much EXP is given when an artifact with the
        given level is salvaged. Only an estimate because exact current
        EXP is unknown.

        Args:
            lvl (int): Current artifact's level

        Returns:
            int: Estimated EXP
        """
        
        return int(3780 + 0.8 * ARTIFACT_REQ_EXP[lvl])

    @staticmethod
    def read_json(filename, split=False):
        """Read JSON of artifacts.

        Args:
            filename (str): JSON filename.
            split (bool, optional): Whether to split the list of
            artifacts into 6 separate lists based on their levels.
            Defaults to False. 

        Raises:
            ValueError: If format isn't GOOD.

        Returns:
            list: List of List of FastArtifact if split, List of FastArtifact
            otherwise.
        """
        with open(filename) as f:
            data = json.load(f) 
        
        if data['format'] != 'GOOD':
            raise ValueError('Format is not GOOD')
        
        artifacts = []
        artifact_dicts = data['artifacts']

        if split:
            buckets = [[] for _ in range(6)]
            for artifact_dict in artifact_dicts:
                if artifact_dict['rarity'] != 5:
                    continue

                (buckets[artifact_dict['level'] // 4]).append(FastArtifact.serialize(artifact_dict))

            return tuple(buckets)
        else:
            for artifact_dict in artifact_dicts:
                if artifact_dict['rarity'] != 5:
                    continue

                artifacts.append(FastArtifact.serialize(artifact_dict))
        
        return artifacts
    
    @staticmethod
    def split_maxed(artifacts):
        maxed = []
        nonmaxed = []
        for artifact in artifacts:
            if artifact.lvl == 20:
                maxed.append(artifact)
            else:
                nonmaxed.append(artifact)
                
        return maxed, nonmaxed
    
    @staticmethod
    def split_slot(artifacts):
        """Split a list of artifacts into 5 seperate lists based on
        their slots.

        Args:
            artifacts (list): List of FastArtifact objects.

        Raises:
            ValueError: FastArtifact is malformed and has an invalid slot.

        Returns:
            tuple: Tuple of 5 lists for each slot
        """
        flowers = []
        plumes = []
        sands = []
        goblets = []
        circlets = []
        for artifact in artifacts:
            match artifact.slot:
                case 'flower':
                    flowers.append(artifact)
                case 'plume':
                    plumes.append(artifact)
                case 'sands':
                    sands.append(artifact)
                case 'goblet':
                    goblets.append(artifact)
                case 'circlet':
                    circlets.append(artifact)
                case _:
                    raise ValueError('Invalid artifact slot')
        
        return flowers, plumes, sands, goblets, circlets
    
    @staticmethod
    def split_lvl(artifacts):
        """Split a list of artifacts into 6 seperate lists based on
        their levels.

        Args:
            artifacts (list): List of FastArtifact objects.

        Raises:
            ValueError: FastArtifact is malformed and has an invalid level.

        Returns:
            tuple: Tuple of 6 lists for each level
        """
        
        output = [None] * 6
        for artifact in artifacts:
            output[artifact // 4].append(artifact)
        
        return tuple(output)